---
layout: post
title:  "사용자 기본 기능 제작"
date:   2015-08-08 07:00:00
categories: Nodejs서버강좌 Nodejs
comments: true
meta : Node.js서버강좌 - 4
description : 사용자와 관련된 기본 기능을 제작합니다.
publish : false
---

* content
{:toc}

## 들어가는 말

가입 요청 기능, 로그인 기능 등을 제작하며 사용자와 관련된 기본 기능이 어떤 것인지 살펴보고 Node.js 기능을 익힌다.

---

## 라우터(Router) 살펴보기

라우터는 특정 URL로 들어오는 요청(HTTP Request)를 처리하는 패턴이다. 예를 들면 Sequelize를 다룬 이전 포스트 URL은 `http://totuworld.github.io/2015/08/07/sequelize`이다.

프로토콜 | 호스트 | 패스(path)
--- | --- | ---
http:// | totuworld.github.io | /2015/08/07/sequelize

express에서 사용되는 라우터는 패스와 콜백 메서드로 이뤄진다.

{% highlight javascript %}

router.METHOD( /* 패스(path) */ , /* 콜백 메서드(callback method) */ );  

{% endhighlight %}

앞의 METHOD는 HTTP 메서드(get, post, put 등)를 제공한다. 패스는 URL의 패스를 입력하면 된다. 콜백 메서드가 실제로 모든 일을 처리하게 된다.

---

## 가입 요청 처리

게임을 실행했을 때 사용자 아이디의 유무를 확인힌다. 이때 아이디가 없는 경우 게스트 로그인이나 소셜 미디어를 통한 가입을 권유해야 한다. 

위와 같은 과정이 클라이언트에서 실행된 후 실제적인 가입 요청이 왔다고 가정하자. 웹 어플리케이션에서는 어떤 일을 수행해야할까? 크게 아이디 중복 여부 확인과 기본 정보 등록으로 나눌 수 있다. 이런 내용을 `routes/users.js` 파일에 추가하자.

먼저 스크립트 앞에 데이터베이스 모델을 사용할 수 있도록 아래 코드를 추가한다.

    var models = require('../models');

그리고 가입 요청 처리하는 로직을 작성해 넣는다.  

{% highlight javscript %}

/* POST 사용자 아이디를 등록할 때 사용한다. */
router.post('/add/:userID', function(req, res) {

  //아이디 중복 확인
  models.usercore.find({where:{id:req.params.userID}})
  .then(function(findUserCoreData) {
    if( (findUserCoreData == null || findUserCoreData == undefined) == false ) {
      //err:아이디가 중복되는 경우.
      res.send('exist');
      return;
    }
    
    //아이디를 등록한다.
    models.usercore
    .create({id:req.parmas.userID, gems:20, coins:1000, hearts:5})
    .then(function(createdUserCore) {
      //완료 결과 전송.
      res.send('done0'+createduserCore.no);
    });
  });
  
});

{% endhighlight %}

5번째 줄: Sequelize.js가 제공하는 find 메서드[^1]를 사용했다. `{where:{/* 조건 */}` 형태로 옵션을 넣으면 콜백으로 입력한 조건과 맞는 usercore 테이블의 행(row)를 리턴한다. 

7번째 줄: 리턴된 행이 `null`이거나 `undefined`일 때를 확인하여 `false`이면 아이디가 중복인 것으로 판단한다.

14번째 줄: 아이디가 중복되지 않으므로 create 메서드[^2]로 아이디를 등록한다. 필요한 컬럼을 `{/* 초기값 */}`형태로 입력하면 새 행을 만들고 콜백으로 만들어진 행을 리턴한다. 

20줄 정도되는 코드에 벌써부터 Node.js의 단점인 콜백 지옥(callback hell)나타났다. 해석도 어렵고 다시 코드를 수정할 때도 길을 잃기 좋다. 왜 이렇게 되었는가?

Node.js는 비동기 처리가 많아 콜백 메서드가 사용된다. 그러다보니 콜백 안에서 다시 콜백을 호출하는 일이 많다. 

> 이렇게 작성하면 에러에 대한 처리와 개발 코드에 대한 관리가 매우 어려워진다.
> - [고재도](http://webframeworks.kr/tutorials/angularjs/angularjs_promise_deferred/)

이를 극복하기 위해서 [Promise.js](https://www.promisejs.org)나 [Async.js](https://github.com/caolan/async) 모듈을 활용할 필요가 있다. 여기서는 Async.js를 사용한다.[^3]

    npm install async --save

위와 같이 입력하여 Async 모듈을 설치한다. Async 모듈을 사용하기 위해 아래 코드를 넣는 것을 잊지 말자.

    var async = require('async');
    
그리고 Async 모듈을 활용해 앞서 작성한 코드를 수정한다.

{% highlight javascript linenos %}

/* POST 사용자 아이디를 등록할 때 사용한다. */
router.post('/add/:userID', function(req, res) {
  
  //아이디 중복 확인
  function CheckIsHaveID(callback) {
    models.usercore.find({where:{id:req.params.userID}})
    .then(function(findUserCoreData) {
      callback( !(findUserCoreData == null || findUserCoreData == undefined) );
    });
  }
  //아이디를 등록한다.
  function CreateAccount(callback) {
    models.usercore
    .create({id:req.parmas.userID, gems:20, coins:1000, hearts:5})
    .then(function(createdUserCore) {
      callback(null, createdUserCore.no);
    });
  }

  async.series([
    CheckIsHaveID,
    CreateAccount
  ], function(err, results) {
    if(err) {
      //err:아이디가 중복되는 경우.
      res.send('exist');
    }
    else {
      //완료 결과 전송.
      res.send('done0'+results[1]);
    }
  });
  
});

{% endhighlight %}

5, 12 번 줄 : 아이디 중복 검사하는 메서드와 아이디 등록하는 메서드를 추가했다.

20 번 줄 : [`async.series`메서드](https://github.com/caolan/async#seriestasks-callback)를 활용해서 처리해야하는 일을 순차적으로 기록했다. 끝에서 에러 처리와 결과 처리를 하므로 편리하다.

코드를 보면 콜백 메서드를 사용하는 것은 동일하다. 다만 Async 모듈을 활용해 흐름이 명확히 보인다. 어디서 결과를 리턴하고 에러를 처리하는지 분명해 졌기 때문이다.  

---

[^1]: [find 메서드](http://docs.sequelizejs.com/en/latest/docs/models-usage/)는 데이터베이스에서 조건에 맞는 하나의 데이터를 찾을 때 사용한다.

[^2]: [create 메서드](http://docs.sequelizejs.com/en/latest/docs/instances/#creating-persistent-instances)는 테이블에 행을 추가할 때 사용한다.

[^3]: Async.js를 사용한 이유는 아직까지 Node.js의 많은 모듈이 콜백 메서드를 사용하는 형태가 많기 때문이다. 하지만 차차 Promise.js를 사용하고 있으므로 대세의 흐름에 맞춰 더 공부하는 것도 좋겠다.