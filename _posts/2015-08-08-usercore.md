---
layout: post
title:  "사용자 기본 기능 제작"
date:   2015-08-08 07:00:00
categories: Nodejs서버강좌 Nodejs
comments: true
meta : Node.js서버강좌 - 4
description : 사용자와 관련된 기본 기능을 제작합니다.
publish : false
---

* content
{:toc}

## 들어가는 말

가입 요청 기능, 로그인 기능 등을 제작하며 사용자와 관련된 기본 기능이 어떤 것인지 살펴보고 Node.js 기능을 익힌다.

---

## 라우터(Router) 살펴보기

라우터는 특정 URL로 들어오는 요청(HTTP Request)를 처리하는 패턴이다. 예를 들면 Sequelize를 다룬 이전 포스트 URL을 부분별로 나눠보면 아래 표와 같다.

프로토콜 | 호스트 | 패스(path)
--- | --- | ---
http:// | totuworld.github.io | /2015/08/07/sequelize

express의 라우터는 패스와 콜백 메서드로 이뤄진다.

{% highlight javascript %}

router.METHOD( /* 패스(path) */ , /* 콜백 메서드(callback method) */ );  

{% endhighlight %}

앞의 METHOD는 HTTP 메서드(get, post, put 등)를 제공한다. 패스는 URL의 패스를 입력하면 된다. 콜백 메서드가 실제로 모든 일을 처리하게 된다.

---

## 가입 요청 처리

게임을 실행했을 때 사용자 아이디의 유무를 확인힌다. 이때 아이디가 없는 경우 게스트 로그인이나 소셜 미디어를 통한 가입을 권유해야 한다. 

위와 같은 과정이 클라이언트에서 실행된 후 실제적인 가입 요청이 왔다고 가정하자. 웹 어플리케이션에서는 어떤 일을 수행해야할까? 크게 아이디 중복 여부 확인과 기본 정보 등록으로 나눌 수 있다. 이런 내용을 `routes/users.js` 파일에 추가하자.

먼저 스크립트 앞에 데이터베이스 모델을 사용할 수 있도록 아래 코드를 추가한다.

    var models = require('../models');

그리고 가입 요청 처리하는 로직을 작성해 넣는다.  

{% highlight javascript linenos %}

/* POST 사용자 아이디를 등록할 때 사용한다. */
router.post('/add/:userID', function(req, res) {

  //아이디 중복 확인
  models.usercore.find({where:{id:req.params.userID}})
  .then(function(findUserCoreData) {
    if( (findUserCoreData == null || findUserCoreData == undefined) == false ) {
      //err:아이디가 중복되는 경우.
      res.send('exist');
      return;
    }
    
    //아이디를 등록한다.
    models.usercore
    .create({id:req.parmas.userID, gems:20, coins:1000, hearts:5})
    .then(function(createdUserCore) {
      //완료 결과 전송.
      res.send('done0'+createduserCore.no);
    });
  });
  
});

{% endhighlight %}

5번째 줄: Sequelize.js가 제공하는 find 메서드[^1]를 사용했다. `{where:{/* 조건 */}` 형태로 옵션을 넣으면 콜백으로 입력한 조건과 맞는 usercore 테이블의 행(row)를 리턴한다. 

7번째 줄: 리턴된 행이 `null`이거나 `undefined`일 때를 확인하여 `false`이면 아이디가 중복인 것으로 판단한다.

14번째 줄: 아이디가 중복되지 않으므로 create 메서드[^2]로 아이디를 등록한다. 필요한 컬럼을 `{/* 초기값 */}`형태로 입력하면 새 행을 만들고 콜백으로 만들어진 행을 리턴한다. 

20줄 정도되는 코드에 벌써부터 Node.js의 단점인 콜백 지옥(callback hell)나타났다. 해석도 어렵고 다시 코드를 수정할 때도 길을 잃기 좋다. 왜 이렇게 되었는가?

Node.js는 비동기 처리가 많아 콜백 메서드가 사용된다. 그러다보니 콜백 안에서 다시 콜백을 호출하는 일이 많다. 

> 이렇게 작성하면 에러에 대한 처리와 개발 코드에 대한 관리가 매우 어려워진다.
> - [고재도](http://webframeworks.kr/tutorials/angularjs/angularjs_promise_deferred/)

이를 극복하기 위해서 [Promise.js](https://www.promisejs.org)나 [Async.js](https://github.com/caolan/async) 모듈을 활용할 필요가 있다. 여기서는 Async.js를 사용한다.[^3]

    npm install async --save

위와 같이 입력하여 Async 모듈을 설치한다. Async 모듈을 사용하기 위해 아래 코드를 넣는 것을 잊지 말자.

    var async = require('async');
    
그리고 Async 모듈을 활용해 앞서 작성한 코드를 수정한다.

{% highlight javascript linenos %}

/* POST 사용자 아이디를 등록할 때 사용한다. */
router.post('/add/:userID', function(req, res) {
  
  //아이디 중복 확인
  function CheckIsHaveID(callback) {
    models.usercore.find({where:{id:req.params.userID}})
    .then(function(findUserCoreData) {
      callback( !(findUserCoreData == null || findUserCoreData == undefined) );
    });
  }
  //아이디를 등록한다.
  function CreateAccount(callback) {
    models.usercore
    .create({id:req.parmas.userID, gems:20, coins:1000, hearts:5})
    .then(function(createdUserCore) {
      callback(null, createdUserCore.no);
    });
  }

  async.waterfall([
    CheckIsHaveID,
    CreateAccount
  ], function(err, usercore_no) {
    if(err) {
      //err:아이디가 중복되는 경우.
      res.send('exist');
    }
    else {
      //완료 결과 전송.
      res.send('done0'+usercore_no);
    }
  });
  
});

{% endhighlight %}

5, 12 번 줄 : 아이디 중복 검사하는 메서드와 아이디 등록하는 메서드를 추가했다. 앞서 제작한 코드처럼 익명 함수(Anonymous function)로 async의 작업(Task) 배열 안에서 처리할 수도 있다. 

20 번 줄 : [`async.waterfall`메서드](https://github.com/caolan/async#waterfalltasks-callback)를 활용하여 작업(Task)을 순차적으로 등록하여 처리했다.

코드를 보면 콜백 메서드를 사용하는 것은 동일하다. 다만 Async 모듈을 활용해 흐름이 명확히 보인다. 어디서 결과를 리턴하고 에러를 처리하는지 분명해 졌기 때문이다.  

---

## 업그레이드 기록 테이블 추가

사용자의 공격, 방어 레벨등을 기록하는 `userupgrade`테이블을 추가한다.

Name | Type | Default | Attributes | Index | AutoIncrease
--- |:--- | --- | --- | --- | ----
no | INTEGER | - | UNSIGNED | PRIMARY | -
attLv | INTEGER | 1 | UNSIGNED | - | -
defLv | INTEGER | 1 | UNSIGNED | - | -
moneyLv | INTEGER | 1 | UNSIGNED | - | -

no는 `usercore`의 no와 같은 값이 할당된다.[^4] 나머지 컬럼은 공격, 방어, 코인 획득 레벨을 나타내게 된다.

`models/userupgrade.js`파일을 생성하고 아래 링크와 같은 내용으로 입력한다.

[userupgrade.js](https://github.com/totuworld/FarmDefence_NodeServer/blob/master/models/userupgrade.js)


파일이 추가되면 `users.js`파일에 다음과 같은 메서드를 만들고 가입 시에 해당 데이터도 자동 생성되도록 async.waterfall의 작업 목록에 추가한다.

{% highlight javascript linenos %}

  //userupgrade테이블에 업그레이드 기록할 행을 추가한다.
  function CreateUserUpgradeRow(no, callback) {
    models.userupgrade.create({no:no})
    .then(function(createdUserUpgrade) {
      callback(null, no);
    });
  }

  async.waterfall([
    CheckIsHaveID,
    CreateAccount,
    CreateUserUpgradeRow
  ], function(err, usercore_no) {
    if(err) {
      //err:아이디가 중복되는 경우.
      res.send('exist');
    }
    else {
      //완료 결과 전송.
      res.send('done0'+usercore_no);
    }
  });

{% endhighlight %}

2 번 줄 : create메서드인데 초기값을 `no`만 할당했다. 나머지 값은 `userupgrade`테이블에 정의된 `defaultValue`를 그대로 사용하면 되기 때문이다.

12 번 줄 : 작업 추가도 간단하다. 다만 유의해야하는 점은 작성한 메서드에서 콜백 메서드로 결과를 전달하는 부분이다. 

지금까지 만든 메서드와 콜백의 인수(Argument)를 살펴보자.

메서드 | 인수(Argument)
--- |:---
CheckIsHaveID | true or false
CreateAccount | null, int
CreateUserUpgradeRow | null, int

인수 중 첫번째는 true, false, null 중 하나이다. `async.waterfall`의 콜백 메서드는 아래와 같은 형태이다. 

  callback(err, [results]) 

첫번째 매개변수(Parameter)가 에러를 담당한다. 인수로 true, int, string 등의 값이 들어가면 에러로 파악하고 다음 작업이 있어도 콜백 메서드를 바로 호출하게 된다. 이런 특징이 에러처리를 편리하게 한다.

그리고 `async.waterfall`은 이전 작업에서 다음 작업으로 인수를 전달할 수 있다. `CreateAccount`메서드 콜백에서 `createdUserCore.no`를 인수로 전달하면 `CreateUserUpgradeRow`메서드의 `no` 매개변수로 수신이 가능한 것이다. 마지막으로 `CreateUserUpgradeRow`에서 콜백으로 `no`를 전달하면 `async.waterfall`의 콜백 메서드 `usercore_no` 매개변수에 할당된다.

---

## 로그인 기능 처리 

로그인 기능을 만들자!

---

[^1]: [find 메서드](http://docs.sequelizejs.com/en/latest/docs/models-usage/)는 데이터베이스에서 조건에 맞는 하나의 데이터를 찾을 때 사용한다.

[^2]: [create 메서드](http://docs.sequelizejs.com/en/latest/docs/instances/#creating-persistent-instances)는 테이블에 행을 추가할 때 사용한다.

[^3]: Async.js를 사용한 이유는 아직까지 Node.js의 많은 모듈이 콜백 메서드를 사용하는 형태가 많기 때문이다. 하지만 차차 Promise.js를 사용하고 있으므로 대세의 흐름에 맞춰 더 공부하는 것도 좋겠다.

[^4]: 책에서는 user란 컬럼명을 사용했지만 여기서는 no로 통일했다.